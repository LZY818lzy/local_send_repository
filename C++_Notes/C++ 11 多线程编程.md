# C++ 11 多线程编程

## 1、线程库 `thread`的基本使用

- 创建线程————可调用的函数或者函数对象，作为线程入口点
  - `std::thread t(function_name,args...)`
- `thread1.join();`//主线程等待线程结束后再结束
- `thread1.detach();`//分离子线程和主线程
- `thread1.joinable()`判断是否可以使用`join()`/`detach()`

```c++
#include<iostream>
using namespace std;
#include<thread>

void printHelloWorld(string msg)
{
	cout << msg << endl;
	return;
}

int main()
{
	//1、创建线程
	std::thread thread1(printHelloWorld,"helloworld");
	//thread1.join();//主线程等待线程结束后再结束
	//thread1.detach();//分离子线程和主线程
	/*for (int i = 0; i < 100; i++)
	{
		cout << i << endl;
	}*/

	bool isJoin = thread1.joinable();

	if (isJoin)
	{
		cout << "可以成功使用join/detach" << endl;
		thread1.join();
	}
	else
	{
		cout << "不可以使用join/detach" << endl;
	}
	return 0;
}
```

## 2、线程函数中的数据未定义错误

### （1）传递临时变量的问题：

- **传递参数类型要统一**

```c++
void foo(int& x)
{
	x += 1;
}

int main()
{
	//std::thread t(foo, 1);
	////当您调用std::thread t(foo, 1); 时，发生了以下过程：
	////字面值1被传递给std::thread构造函数，std::thread内部会创建参数的副本（临时变量）
	////这些副本被传递给线程函数foo，但foo期望一个非常量左值引用(int&)，而临时变量不能绑定到非常量引用
	//t.join();

	//std::ref传递引用类型——确保线程函数操作的是原始变量而非副本。
	int value = 1; // 创建局部变量
	std::thread t(foo, std::ref(value)); // 使用std::ref传递引用
	t.join();
	cout << value << endl;
	return 0;
}
```

### （2）传递指针或引用指向局部变量的问题：

```c++
#include<iostream>
using namespace std;
#include<thread>

std::thread t;// 声明一个全局的线程对象
int a=1;//全局变量a

void foo(int& x)//调用a的引用的时候，局部变量已经被释放了
{
	x += 1;
}

void test()
{
	//int a = 1;// 局部变量a，初始化为1
	t = std::thread(foo, std::ref(a));
	//在test()函数中创建的局部变量a在函数结束后会被销毁，但新创建的线程引用传递访问这个已经被销毁的变量。
	//这会导致未定义行为，可能引发程序崩溃或产生不可预测的结果。
}

int main()
{
	test();
	t.join();
	return 0;
}
```

### （3）传递指针或引用指向已释放的内存的问题

```c++
//线程函数foo中，尝试解引用指针x并打印其值。但由于在线程启动后，立即删除了指针指向的内存，线程可能在实际执行时访问已经释放的内存，这会导致未定义行为。
#include<iostream>
using namespace std;
#include<thread>

void foo(int *x)
{
	cout << *x << endl;//输出：随机值
}


int main()
{
	int* ptr = new int(1);
	std::thread t(foo, ptr);
	//delete ptr;
	//t.join();
    //改进：先等待子线程进行完再释放内存
    t.join();
    delete ptr;
	return 0;
}
```

### （4）类成员函数作为入口函数，类对象被提前释放

```c++
#include <iostream>
#include <thread>

class SimpleClass {
public:
    void doWork() {
        for (int i = 0; i < 5; i++) {
            std::cout << "线程工作: " << i << std::endl;
        }
    }
    
    ~SimpleClass() {
        std::cout << "对象被销毁" << std::endl;
    }
};

int main() {
    std::thread t;
    
    {
        SimpleClass obj; // 创建对象
        
        // 启动线程，使用对象的成员函数
        t = std::thread(&SimpleClass::doWork, &obj);
        
        // 立即离开作用域
    } // obj在这里被销毁，但线程还在运行
    
    t.join(); // 等待线程结束
    
    return 0;
}
```

### （5）入口函数为类的私有成员函数

```c++
#include <iostream>
#include <thread>

class MyClass {
private:
    void privateWork() { // 私有成员函数
        std::cout << "私有成员函数正在执行" << std::endl;
    }
    
public:
    void startThread() {
        // 尝试直接使用私有成员函数创建线程 - 这会编译错误
        std::thread t(&MyClass::privateWork, this);
        t.detach();
    }
};

int main() {
    MyClass obj;
    obj.startThread();
    
    // 等待一下让线程有机会执行
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    return 0;
}
```

- 使用友元函数（不推荐，破坏封装性）

- 使用公有静态函数作为包装（推荐，保持封装性）

  ```c++
  #include <iostream>
  #include <thread>
  
  class MyClass {
  private:
      void privateWork() {
          std::cout << "私有成员函数正在执行" << std::endl;
      }
      
  public:
      // 公有静态函数作为线程入口
      static void threadEntry(MyClass* obj) {
          obj->privateWork();
      }
      
      void startThread() {
          std::thread t(&MyClass::threadEntry, this);
          t.detach();
      }
  };
  
  int main() {
      MyClass obj;
      obj.startThread();
      
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
      
      return 0;
  }
  ```

  

- 使用Lambda表达式捕获this指针（现代C++推荐方法）