# 第17章  并发与多线程

## 17.1 基本概念和实现

### 1、并发

- **并发**指的是系统能够处理多个任务的能力，这些任务在时间上可能重叠执行。
- 在单核处理器上，并发通过时间片轮转实现，CPU在不同任务之间快速切换，给人同时执行的错觉。在多核处理器上，并发可以真正实现多个任务同时执行。
- 从C++11开始，标准库提供了完整的线程支持库（`<thread>`），使得编写跨平台并发程序变得更加容易。

### 2、可执行程序

- **可执行程序**是存储在磁盘上的二进制文件，包含计算机可以直接执行的机器指令。
- 在Windows系统中通常是`.exe`文件，在Linux/Unix系统中是没有扩展名的文件。

### 3、进程

- **进程**是操作系统中正在执行的程序的实例。每个进程都有自己独立的内存空间、系统资源和执行状态。

### 4、线程

- **线程**是进程内的执行单元，是CPU调度的基本单位。一个进程可以包含多个线程，所有线程共享进程的内存空间和系统资源。
- 每个进程都有一个主线程且唯一。当运行一个可执行程序，产生一个进程后，这个主线程就随着这个进程默默启动起来了。

## 17.2 线程启动、结束与创建线程写法

- 主线程从**`main`主函数**开始执行，如果`main`函数执行结束，也就是主线程运行结束，也就意味着整个进程就运行结束了。
- 自己创建一个线程（叫做**子线程**），子线程从一个函数（初始函数）开始执行。
- 整个进程的结束标志是**主线程是否执行完毕**，如果主线程执行完毕，子线程还没有进行完，子线程则会被**强制终止**。
- 创建线程的写法：

### 1、普通函数作为线程函数

- 包含头文件`#include<thread>`
- 创建的子线程必须从一个函数开始运行，`myprint`作为线程的入口函数。
- 在main函数中，创建`std::thread`对象，并将`myprint`函数作为参数传入，这会启动一个新线程执行`myprint`函数。调用`mytobj.join()`，使主线程等待新线程执行完毕。
  - `thread`是标准库里的类，用这个类创建对象，对象名为`myprint`
  - `join`成员函数，用来等待`myprint`函数运行完成。
  - `detach`指主线程不和子线程回合，各自执行各自的，主线程不必等子线程运行结束，可以先执行结束，并不会影响子线程的执行。
  - 注意：针对一个线程，一旦调用了`detach`，就不可以再调用`join`，否则会导致程序运行异常。

```c++
#include <iostream>
#include <thread>

using namespace std;

// 普通函数作为线程函数
void myprint()
{
	cout << "我的线程开始执行了" << endl;
	//...
	//Sleep(1000); //休息1000毫秒（1秒）
	cout << "我的线程执行完毕了" << endl;	
	return;
}

int main()
{	
    // 创建线程对象，传入函数指针作为参数，从myprint函数开始运行
    std::thread mytobj(myprint);  
    // 等待myprint线程执行完毕
    mytobj.join(); 
    // 主线程执行
    cout << "main主函数执行结束!" << endl; 
    return 0;
}
```

- `joinable()`——判断针对某个线程是否调用过`join`或者`detach`

### 2、用类来创建线程——使用函数对象（仿函数）

```c++
#include <iostream>
#include <thread>
using namespace std; 

class TA
{
public:
	//仿函数————重载圆括号
	void operator()()  //不带参数
	{
		cout << " TA::operator()开始执行了" << endl;
		//....
		cout << " TA::operator()执行结束了" << endl;
	}
};

int main()
{
	TA ta;
	thread mytobj3(ta); //ta，可调用对象
    //ta：这里不可以是临时对象thread mytobj3(TA()); 否则编译无法通过
	mytobj3.join(); //为保证等待线程执行结束，这里使用join.
	cout << "main主函数执行结束!" << endl;

}
```

- 类和`detach`结合使用
  - 使用 `detach()` 分离线程意味着：
    - 主线程不会等待子线程完成
    - 子线程在后台独立运行
    - 如果子线程访问主线程的局部变量，当主线程结束时，这些变量会被销毁，导致悬空引用

```c++
#include <iostream>
#include <thread>
using namespace std; 
class TA
{
public:
    TA(int& i) :m_i(i)()// 构造函数，接受一个int的引用，并初始化成员引用m_i
	void operator()()  // 重载函数调用运算符，使TA对象可调用
	{
		cout << "mi1的值为:" << m_i << endl; //隐患，m_i可能没有有效值
		cout << "mi2的值为:" << m_i << endl;
		cout << "mi3的值为:" << m_i << endl;
		cout << "mi4的值为:" << m_i << endl;
		cout << "mi5的值为:" << m_i << endl;
		cout << "mi6的值为:" << m_i << endl;
	}
	int& m_i; //引入一个引用类型的成员变量
};
int main()
{
    int myi = 6;
    TA ta(myi);   // 创建TA对象，ta.m_i引用main函数的局部变量myi
    thread mytobj3(ta);  //创建并执行子线程
    mytobj3.detach();
    cout << "main主函数执行结束!" << endl;
}
```

- 修改问题以后

```c++
//方案1：main主函数不用detach，而用join
mytobj3.join();

//方案2：TA类中m_A成员变量不应该是引用类型
public:
	TA(int i) :m_i(i) {} // 按值传递，而不是引用
	...........
	int m_A;// 值成员，而不是引用
```

### 3、用`lambda`表达式来创建线程

## 17.3 线程传参详解、`detach`坑与成员函数作为线程函数

### 1、传递临时对象作为线程参数

```c++
//正确示例：
void myprint(const int& i, char* pmybuf)//接收一个常量整型引用i和一个字符指针pmybuf
{
	cout << i << endl;     
	cout << pmybuf << endl;
	return;
}

int main()
{
	int mvar = 1;
	int& mvary = mvar; 
	char mybuf[] = "this is a test!";
	std::thread mytobj(myprint, mvar, mybuf);
	mytobj.join();
	cout << "main主函数执行结束!" << endl;
}
```

- 要避免的陷阱1—————`main`函数里`join`换成`detach`

  - 由于线程入口函数传递的是引用、指针，如果采用detach创建线程，则会导致引用、指针悬空问题

  - 如何在使用detach基础上安全将字符串传递到线程函数中？？？？？

  - 改进1：

    - **字符串参数使用 `const string&`**：

      - 避免了直接传递字符指针的安全问题
      - 利用 `std::string` 的自动内存管理
      - C++语言只会为 `const`引用产生临时对象，所以第二个参数要加`const`

    - **整数参数使用值传递**：

      - 避免了引用可能带来的生命周期问题

        ```c++
        void myprint(int i, const string& pmybuf)//参数1 值传递 ； 参数2 常量字符串引用传递
        {
            cout << i << endl;//由于 i 是值传递的，这是线程安全的     
            const char* ptmp = pmybuf.c_str();//c_str() 返回一个指向字符串内部字符数组的常量指针
            cout << pmybuf.c_str() << endl;
            return;
        }
        ```

  - 改进2：

    ```c++
    //std::thread mytobj(myprint, mvar, mybuf);
    std::thread mytobj(myprint, mvar, string(mybuf));//这里直接将mybuf转换成string对象，这可以保证在线程myprint中所用的pmybuf肯定是有效的
    ```

### 总结：

- 如果传递int这种简单类型参数，建议都使用值传递，不要使用引用传递
- 如果传递类对象作为参数，则要避免隐式类型转换，全部在创建线程这一行就构建出临时对象来，然后线程入口函数的形参位置使用引用来作为形参。
- 建议不适用`detach`，只是用`join`
