# 对象移动、移动构造函数与移动赋值运算符

## 1、对象移动的概念（资源权限转移）

把一个不想用了的对象A中部分有用数据提取出来，在构造新对象B时不需要重新构建所有数据，对象A中保留的数据可以直接拿出来用。

复制就是复制一份新的，而移动，是把原对象的指向资源的指针，赋给新的对象成员，也就是所谓的转移所有权，通常的实现就是转移指向数据的那个指针给新对象就行。

## 2、移动构造函数

- 和拷贝构造函数

  ```c++
  Time :: Time (const Time& tmptime)
  {
  }
  ```

  很相似：左值引用 替换为 右值引用

  ```c++
  ClassName(ClassName && other){}
  ```

- 一般用于 从一个临时对象（右值） 窃取资源来初始化新对象，避免不必要的深拷贝。移动构造函数直接将临时对象的资源（如指针）“移动”到新对象,并将临时对象的指针置为空，这样临时对象析构时就不会释放资源。

## 3、移动构造函数 代码演示

### **STEP 1** 两个指向同一个类的不同对象的指针

```c++
#include <iostream>
#include <vector>
using namespace std;

class B
{
public:
	B() :m_bm(100)
	{
		std::cout << "类B的构造函数执行了" << std::endl;
	}
	B(const B& tmp)
	{
		m_bm = tmp.m_bm;
		std::cout << "类B的拷贝构造函数执行了" << std::endl;
	}

	virtual ~B()
	{
		std::cout << "类B的析构函数执行了" << std::endl;
	}
	int m_bm;
};

int main()
{
	B* pb = new B();   //new系统会调用B类的构造函数
	pb->m_bm = 19;
	B* pb2 = new B(*pb); //这种给参数的new系统会调用B类的拷贝构造函数
	delete pb;
	delete pb2;
}	

```

- `B* pb = new B();` 
  - `B* pb`: 声明一个指向 `B` 类对象的指针 `pb`
  - `new B()`: 在堆内存中动态分配一个 `B` 类对象，并调用其构造函数
  - **整个表达式将新创建的对象的地址赋值给指针 `pb`**
- `pb->m_bm = 19;`
  - `pb->m_bm`: 使用 `->` 运算符通过指针访问对象的成员变量
  - 这相当于 `(*pb).m_bm = 19;`，即先解引用指针，然后访问成员
- `B* pb2 = new B(*pb);` 
  - **`*pb`: 解引用指针 `pb`，获取它指向的 `B` 类对象**
  - `new B(*pb)`: 使用拷贝构造函数创建一个新的 `B` 类对象，该对象是 `*pb` 的副本
  - 将新对象的地址赋值给指针 `pb2`
- `delete pb;`  `delete pb2;`
  - `delete`: 释放通过 `new` 分配的内存
  - 当调用 `delete` 时，会先调用对象的析构函数，然后释放内存

#### 内存管理图示

```
堆内存:
+---------------------+
| B对象 (由pb指向)    |
| m_bm = 19          |
+---------------------+
| B对象 (由pb2指向)   |
| m_bm = 19          | ← 通过拷贝构造函数从pb指向的对象复制而来
+---------------------+

栈内存:
+---------------------+
| 指针pb → 指向第一个B对象 |
+---------------------+
| 指针pb2 → 指向第二个B对象|
+---------------------+
```

### **step2** 两个不同的类，在类A里面创建类B的对象 产生临时对象

```c++
//添加  类A   全局函数getA()
//修改 main函数
class A
{
public:
	A() :m_pb(new B()) //这要调用类B的构造函数
	{
		std::cout << "类A的构造函数执行了" << std::endl;
	}
	A(const A& tmpa) : m_pb(new B(*(tmpa.m_pb))) //这要调用类B的拷贝构造函数
	{
		std::cout << "类A的拷贝构造函数执行了" << std::endl;
	}

	~A()
	{
		delete m_pb;
		std::cout << "类A的析构函数执行了" << std::endl;
	}

private:
	B* m_pb;
};

//普通函数getA
static A getA()
{
	A a;
	return a;  //调用拷贝构造函数
}

int main()
{
	B* pb = new B();   //new系统会调用B类的构造函数
	pb->m_bm = 19;
	B* pb2 = new B(*pb); //这种给参数的new系统会调用B类的拷贝构造函数
	delete pb;
	delete pb2;

	A a = getA();
}
```

**执行结果**——A拷贝构造然后B拷贝构造  然后才B析构 A析构

```
类B的构造函数执行了        // new B() 为 pb
类B的拷贝构造函数执行了     // new B(*pb) 为 pb2
类B的析构函数执行了        // delete pb
类B的析构函数执行了        // delete pb2
类B的构造函数执行了        // A构造函数中的 new B()
类A的构造函数执行了        // getA() 中的 A a 构造
类A的拷贝构造函数执行了    // return a 时的拷贝构造（可能被优化掉）
类B的拷贝构造函数执行了    // A拷贝构造函数中的 new B(*(tmpa.m_pb))
类B的析构函数执行了        // getA() 返回后局部对象 a 的析构
类A的析构函数执行了        // getA() 返回后局部对象 a 的析构
类B的析构函数执行了        // main 中 a 析构时删除 m_pb
类A的析构函数执行了        // main 中 a 析构
```

`getA()` 函数的执行过程：

1. 创建局部对象 `A a`，调用 A 的构造函数
   - A 的构造函数中创建 B 对象：`new B()`，调用 B 的构造函数
   - 然后输出 "类A的构造函数执行了"
2. 返回 `a` 对象
   - 理论上应该创建一个临时对象，调用 A 的拷贝构造函数
   - A 的拷贝构造函数中创建 B 对象：`new B(*(tmpa.m_pb))`，调用 B 的拷贝构造函数
   - 然后输出 "类A的拷贝构造函数执行了"
3. `getA()` 函数结束时，局部对象 `a` 被析构
   - 调用 A 的析构函数，其中 `delete m_pb`，调用 B 的析构函数
   - 然后输出 "类A的析构函数执行了"

### **step 3** 添加移动构造函数

```c++
//给类A 添加 一个移动构造函数
	A(A&& tmpa)
	{
		std::cout << "类A的移动构造函数执行了" << std::endl;
	}
//普通函数getA
static A getA()
{
	A a;
	return a;  //这里会执行类A的移动构造函数，不进行拷贝构造函数，把对象a的数据移动给要返回的临时对象
}
```

##### 执行结果 ：A移动构造以后直接进行B析构，因为B此时置空

```
类B的构造函数执行了        // new B() 为 pb
类B的拷贝构造函数执行了     // new B(*pb) 为 pb2
类B的析构函数执行了        // delete pb
类B的析构函数执行了        // delete pb2
类B的构造函数执行了        // A构造函数中的 new B()
类A的构造函数执行了        // getA() 中的 A a 构造
类A的移动构造函数执行了    // return a 时调用移动构造函数（而不是拷贝构造函数）
类B的析构函数执行了        // getA() 返回后局部对象 a 的析构（此时m_pb已为nullptr，不会删除B对象）
类A的析构函数执行了        // getA() 返回后局部对象 a 的析构
类B的析构函数执行了        // main 中 a 析构时删除 m_pb
类A的析构函数执行了        // main 中 a 析构
```

### **step 3** 修改移动构造函数  处理m_pb成员变量

```c++
 //继续优化：移动构造函数通常应该标记为 noexcept，因为移动操作不应该抛出异常

//形参tmpa就是a1对象
//这个初始化列表将新对象的 m_pb 直接指向原对象 tmpa 的 m_pb 所指向的内存
	A(A&& tmpa) noexcept :m_pb(tmpa.m_pb) 
   //原来对象a1中m_pb指向的内存由临时对象(a2)的m_pb接管
	{
		tmpa.m_pb = nullptr; // 将原对象的资源指针置空
		std::cout << "类A的移动构造函数执行了" << std::endl;
	}
```

移动构造函数的本质是"资源盗窃"：

1. 新对象"偷走"原对象的资源
2. 原对象被留下一个空壳（资源指针置为空）
3. 原对象仍然可以安全析构（删除空指针是安全的）

```c++
//修改main函数
int main()
{
	A a=getA();//A构造->A移动->A析构
    A a1(a);//调用类A的拷贝构造函数 ->A析构->A析构
}
```

```c++
//再次修改main函数
int main()
{
    A a=getA();//A构造->A移动->A析构
    A a2(std::move(a));//调用类A的移动构造函数 ->A析构->A析构
}
```

对比两个对象的建立：

1. 系统判断到构造a2对象时，圆括号里面的实参是右值，就会调用移动构造函数。
2. 虽然 第一个移动构造函数里面`a` 在函数内部是左值，但当它作为返回值时：
   1. 编译器首先尝试进行返回值优化（RVO）
   2. 如果RVO不可行，编译器会将返回值视为右值，优先调用移动构造函数
   3. 如果没有移动构造函数，则回退到调用拷贝构造函数

### STEP 4 右值引用

```c++
//继续修改main函数
int main()
{
    A a =getA();
    A && a2(std::move(a));//不产生新对象，因此也不会调用A的移动构造函数
}
```

区别于上一步优化中的`A a2(std::move(a));//调用类A的移动构造函数 ->A析构->A析构`

​	`A a2(std::move(a))`通过a构造新对象A2，因此会调用A的移动构造函数。而`A && a2(std::move(a))`右值引用，相当于a2是a的一个别名，所以并没有构造新对象。



