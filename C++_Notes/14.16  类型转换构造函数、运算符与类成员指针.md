# 类型转换构造函数、运算符、类成员指针

## 1、类型转换构造函数

- 只有一个形参（或多个参数但只有第一个参数没有默认值）

- 可以将参数类型转换成类类型

- 示例

  ```c++
  class TestInt //一个类，里边保存0-100之间的数字
  {
  public:
      // 这就是类型转换构造函数
      TestInt(int x = 0) :m_i(x) // 可以将数字转换成类类型对象
      {
          //这是类型转换构造函数的一个常见用途：在转换过程中对数据进行验证和处理
          if (m_i < 0) m_i = 0;    // 限制一下范围
          if (m_i > 100) m_i = 100;// 限制一下范围
      }
  
  public:
      int m_i;
  };
  
  int main()
  {
      TestInt ti = 12; // 隐式类型转换
      TestInt ti2 = TestInt(12); // 显式调用构造函数，直接调用构造函数创建对象
  }
  ```

  **注：**

  1、**类型转换构造函数** ：`TestInt(int x = 0) :m_i(x)`：

  ​	接受一个`int`类型的参数`x`且`x`默认值为`0`

  ​	使用成员初始化列表，将参数`x`的值赋给成员变量`m_i`

  ​	这个构造函数允许从 `int` 类型到 `TestInt` 类型的转换，当编译器看到需要 `TestInt` 对象但提供了 `int` 值时，会自动调用此构造函数进行转换

​	2、**explicit关键字**：用于防止意外的隐式转换，增加代码安全性

​		`explicit TestInt(int x = 0) : m_i(x)`

禁止隐式转换以后，main函数也只能用显示调用构造函数 `TestInt ti = TestInt(12);`

## 2、类型转换运算符（类型转换函数）

- 类型转换运算符（也称为类型转换函数）是C++中允许类定义如何将自己转换为其他类型的特殊成员函数。
- 类型转换运算符是类的成员函数，它定义了如何将类类型转换为其他类型。它的语法形式为：

```c++
operator 类型名() const;
```

- **注意：**
  - 必须定义为类的成员函数
  - 没有返回类型（因为返回类型就是类型名）
  - 通常是const的（不修改对象状态）
  - 没有形参，形参列表为空

```c++
//示例代码

  // 类型转换运算符 - 将TestInt转换为int
operator int() const 
{
	return m_i;//返回的就是一个int类型，就可以把该类对象转成int类型
}

int main()
{   
// 1. 类型转换构造函数的使用
	TestInt ti = TestInt(12); //显示调用类型转换构造函数
	TestInt ti2(22); //调用类型转换构造函数，但这个不是隐式类型转换
// 2. 赋值时的隐式转换
	ti2 = 6;  //隐式转换把6转成一个临时的TestInt对象，然后调用赋值运算符把临时对象给ti2
// 3.隐式调用 类型转换运算符
	int k = ti2 + 5; //k=11,这里调用operator int()将ti2转成int，结果为6，再和5做加法运算，结果给k
// 4. 显式调用类型转换运算符
	int k2 = ti2.operator int() + 5; //也可以显式的调用。注意写法，没有形参所以括号内为空
}
```

**注：**

- **explicit关键字**：用于防止隐式转换

  ```c++
  explicit operator int() const
  {
      return m_i;//返回的就是一个int类型，就可以把该类对象转成int类型
  }
  ```

- **显示的类型转换运算符**  ：`static_cast<类型名>(变量名)`——显示的强制类型转换运算符

  ```c++
  int main()
  {
  // 1. 类型转换构造函数的使用
  	TestInt ti = TestInt(12); //显示调用类型转换构造函数
  	TestInt ti2(22); //调用类型转换构造函数，但这个不是隐式类型转换
  // 2. 赋值时的隐式转换
  	ti2 = 6;  //隐式转换把6转成一个临时的TestInt对象，然后调用赋值运算符把临时对象给ti2
  // 3.隐式调用 类型转换运算符
  	//int k = ti2 + 5; //k=11,这里调用operator int()将ti2转成int，结果为6，再和5做加法运算，结果给k
      int k = static_cast<int>(ti2) + 5; //11,调用operator int()将ti2转成int，结果为6，再和5做加法运算，结果给k
  // 4. 显式调用类型转换运算符
  	int k2 = ti2.operator int() + 5; //也可以显式的调用。注意写法，没有形参所以括号内为空
  }
  ```

#### 类型转换运算符 vs 类型转换构造函数

| 特性     | 类型转换运算符       | 类型转换构造函数  |
| :------- | :------------------- | :---------------- |
| 方向     | 类类型 → 其他类型    | 其他类型 → 类类型 |
| 声明位置 | 类的成员函数         | 类的构造函数      |
| 参数     | 无参数               | 至少一个参数      |
| 返回类型 | 无（隐含为目标类型） | 无（构造函数）    |

#### **注意事项**

1. **避免循环转换**：不要创建A→B和B→A的循环转换，这会导致编译错误或不可预测的行为
2. **避免二义性**：过多的转换运算符可能导致二义性，编译器无法确定使用哪个转换
3. **谨慎使用隐式转换**：隐式转换可能导致意外的行为，使用`explicit`关键字增加安全性
4. **考虑使用命名函数**：对于复杂的转换，考虑使用命名函数（如`toString()`、`toDouble()`）而不是转换运算符

## 3、类成员函数指针

类成员函数指针是指向类成员函数的指针，它需要指定：

1. 函数的返回类型

2. 函数所属的类

3. 函数的参数列表

4. **基本语法**

   ```c++
   // 声明成员函数指针
   返回类型 (类名 :: * 函数指针变量名)(形参) ;
   
   // 赋值
   函数指针变量名 = & 类名 :类的成员函数名;
   
   // 调用————通过对象实例调用成员函数指针
   (object.*pointerName)(arguments);
   (objectPtr->*pointerName)(arguments);
   ```

#### （1）对于普通成员函数

- `类名 :: * 函数指针变量名` 定义（声明）普通成员函数指针；`& 类名 :类的成员函数名` 获取类成员函数地址。

- 只要成员函数存在，就有成员函数地址。
- 要使用成员函数指针获取的成员函数地址，就必须先实例化一个对象，然后通过 `类对象名 . * 函数指针变量名` 来调用成员函数；或者通过 `指针名 -> * 函数指针变量名`

```c++
#include <iostream>
#include <vector>
using namespace std;

class CT
{
public:
	void ptfunc(int tmpvalue) { cout << "ptfunc普通成员函数被调用,value=" << tmpvalue << endl; }
	virtual void virtualfunc(int tmpvalue) { cout << "virtualfunc虚成员函数被调用,value=" << tmpvalue << endl; }
	static void staticfunc(int tmpvalue) { cout << "staticfunc静态成员函数被调用,value=" << tmpvalue << endl; }
};

int main()
{    
     // 1. 定义普通成员函数指针
    void (CT:: * myfpointpt)(int); //声明一个指向CT类成员函数的指针,该函数接受一个int参数并返回void。
    myfpointpt = &CT::ptfunc;      // 将指针指向ptfunc成员函数
	// 2. 创建对象和对象指针
    CT ct, * pct;
    pct = &ct;
    // 3. 通过对象调用成员函数指针
    (ct.*myfpointpt)(100);        //对象ct,调用成员函数指针变量myfpointpt所指向的成员函数
    // 4. 通过对象指针调用成员函数指针
    (pct->*myfpointpt)(200);      //对pct所指的对象，调用成员函数指针变量myfpointpt所指向的成员函数

return 0;
}
```

#### （2）对于虚成员函数

- 虚函数也可以通过成员函数指针调用，并且会正确地进行动态绑定（如果通过基类指针调用）。

```c++
    void (CT::*myfpointvirtual)(int)= &CT::virtualfunc; //声明虚成员函数指针并指向虚成员函数

    (ct.*myfpointvirtual)(500);  // 通过对象调用
    (pct->*myfpointvirtual)(600); // 通过对象指针调用
```

#### （3）对于静态成员函数

- 静态成员函数指针调用不需要对象，可以直接调用
- 对于静态成员函数，其函数指针的用法与普通函数指针类似，因为静态成员函数不依赖于类的实例。静态成员函数没有 `this` 指针，因此可以直接通过函数名调用。

```c++
    void (*myfpointstatic)(int); // 声明静态成员函数指针
    myfpointstatic = &CT::staticfunc; // 指向静态成员函数

	myfpointstatic(700);         // 直接调用，不需要对象
```

## 4、类成员变量指针

- 类成员变量指针是指向<u>类的非静态成员变量的指针</u>。它们提供了一种间接访问对象成员变量的方式，与普通指针不同，<u>成员变量指针需要与特定对象结合使用</u>。
- 基本语法：

```c++
// 声明成员变量指针
Type ClassName::*pointerName;

// 赋值
pointerName = &ClassName::memberVariable;

// 访问
object.*pointerName;
objectPtr->*pointerName;
```

#### (1) 对于普通成员变量

- 普通成员变量指针并不存储实际的内存地址，而是存储成员变量在类对象中的**偏移量**。

```c++
public:
	int m_a;

//main函数
int CT::*mp = &CT::m_a;//定义一个类成员变量指针mp，并指向类成员变量m_a

CT ct;//实例化类对象
ct.*mp = 189;//通过类成员变量指针来修改类成员变量 等价于ct.m_a=189;
```

#### （2）对于静态成员变量

- 对于静态成员变量，其指针的用法与普通指针完全相同，因为静态成员变量属于类，而不属于任何特定的类实例，静态成员变量指针的地址是一个真正的地址。
  - 静态成员变量在内存中只有一个固定位置
  - 它们不属于任何特定对象实例
  - 静态成员变量指针存储的是实际的内存地址

- 基本语法：

```c++
// 声明静态成员变量指针
Type* pointerName;

// 赋值
pointerName = &ClassName::staticMemberVariable;

// 访问
*pointerName; // 直接解引用
```