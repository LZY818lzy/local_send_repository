# 临时对象

## 1、概念

临时对象 是系统自己产生的，程序员看不见，通过右值引用可以将其绑定出来。

临时对象（Temporary Object）是在表达式求值过程中创建的未命名的对象，它们通常用于存储中间结果。临时对象的生命周期通常很短，只存在于创建它们的表达式执行期间，表达式执行完毕后就会被销毁。

临时对象 是一种 右值

## 2、产生临时对象的情况 

### (1)以传值的方式 给函数传递参数

```c++
class CTempValue
{
public:
	int val1;
	int val2;
public:
    //在C++中，构造函数后的冒号(:)以及后面的部分称为"成员初始化列表"。这是一种专门用于初始化类成员变量的语法结构。
    
    //val1(v1)表示用参数v1初始化成员变量val1
	CTempValue(int v1 = 0, int v2 = 0):val1(v1), val2(v2)
    {
        cout << "调用了构造函数!" << endl;
        cout << "val1 = " << val1 << endl;
        cout << "val2 = " << val2 << endl;
    }
	CTempValue(const  CTempValue& t) : val1(t.val1), val2(t.val2) 
	{
		cout << "调用了拷贝构造函数!" << endl;
	};
	virtual ~CTempValue() //析构函数
	{
		cout << "调用了析构函数!" << endl;
	};
public:
	int Add(CTempValue tobj); //值传递
};

int CTempValue::Add(CTempValue tobj)
{
	int tmp = tobj.val1 + tobj.val2;
	tobj.val1 = 1000;            //这里修改对外界没什么影响
	return tmp;
}
int main()
{
    CTempValue tm(10, 20);    //调用构造函数
    int Sum = tm.Add(tm);     //这会导致拷贝构造函数的执行
    cout << "Sum = " << Sum << endl;
    cout << "tm.val1 = " << tm.val1 << endl;
}
```

输出：

```
调用了构造函数!
val1 = 10
val2 = 20
调用了拷贝构造函数!
调用了析构函数!
Sum = 30
tm.val1 = 10
调用了析构函数!
```

#### 解决方案：使用常量引用传递

```C++
class CTempValue
{
public:
	int val1;
	int val2;
public:
	CTempValue(int v1 = 0, int v2 = 0):val1(v1), val2(v2)
    {
        cout << "调用了构造函数!" << endl;
        cout << "val1 = " << val1 << endl;
        cout << "val2 = " << val2 << endl;
    }
	CTempValue(const  CTempValue& t) : val1(t.val1), val2(t.val2) 
	{
		cout << "调用了拷贝构造函数!" << endl;
	};
	virtual ~CTempValue() //析构函数
	{
		cout << "调用了析构函数!" << endl;
	};
public:
	int Add(CTempValue& tobj); //引用传递
};
int CTempValue::Add(CTempValue& tobj) //引用传递
{
	int tmp = tobj.val1 + tobj.val2;
	tobj.val1 = 1000;            //这里修改对外界直接产生影响
	return tmp;
}
int main()
{
    CTempValue tm(10, 20);    //调用构造函数
    int Sum = tm.Add(tm);     //对比值传递，引用传递避免了拷贝构造函数的调用
    cout << "Sum = " << Sum << endl;
    cout << "tm.val1 = " << tm.val1 << endl;
}

```

输出：

```
调用了构造函数!
val1 = 10
val2 = 20
Sum = 30
tm.val1 = 1000
调用了析构函数!
```

### (2)类型转换生成的临时对象/隐式类型转换以保证函数调用成功

```C++
class CTempValue
{
public:
	int val1;
	int val2;
public:
	CTempValue(int v1 = 0, int v2 = 0):val1(v1), val2(v2)
    {
        cout << "调用了构造函数!" << endl;
        cout << "val1 = " << val1 << endl;
        cout << "val2 = " << val2 << endl;
    }
	CTempValue(const  CTempValue& t) : val1(t.val1), val2(t.val2) 
	{
		cout << "调用了拷贝构造函数!" << endl;
	};
	virtual ~CTempValue() //析构函数
	{
		cout << "调用了析构函数!" << endl;
	};
public:
	int Add(CTempValue& tobj); //引用传递
};
int CTempValue::Add(CTempValue& tobj) //引用传递
{
	int tmp = tobj.val1 + tobj.val2;
	tobj.val1 = 1000;            //这里修改对外界直接产生影响
	return tmp;
}
int main()
{
    CTempValue Sum;
    Sum = 1000;// 这里会调用构造函数创建临时对象，然后使用拷贝赋值运算符
    //cout << "Sum = " << Sum << endl;  
}
```

- **问题1：为什么`cout << "Sum = " << Sum << endl;` 报错？**

回答：

​	使用 `cout << object` 输出一个自定义类的对象时，需要重载运算符<<

- **问题二：此处的Sum是什么？**

回答：

​	Sum是一个左值，首先调用构造函数 `CTempValue(1000, 0)` 创建一个临时对象，调用拷贝构造函数将临时对象的所有属性赋值给Sum对象，然后销毁这个临时对象。

输出：

```
调用了构造函数!
val1 = 0
val2 = 0
调用了构造函数!
val1 = 1000
val2 = 0
调用了析构函数!//临时对象的销毁
调用了析构函数!
```

#### 解决方案——优化

```C++
//把main函数里修改
CTempValue sum = 1000;
//这里的 = 不是赋值运算符，而是定义初始化。
//定义Sum对象后，系统为Sum预留了一段空间。
//整数1000进行隐式转换成CTempValueL类型
//然后调用构造函数CTempValue(1000, 0) 
//构造函数直接在为 sum 预留的内存空间中初始化对象，编译器会优化掉临时对象的创建，所以并没有真正产生临时对象
```

### (3)函数返回对象的时候

```C++
#include<iostream>
using namespace std;

class CTempValue
{
public:
	int val1;
	int val2;
public:
	CTempValue(int v1 = 0, int v2 = 0) :val1(v1), val2(v2)
	{
		cout << "调用了构造函数!" << endl;
		cout << "val1 = " << val1 << endl;
		cout << "val2 = " << val2 << endl;
	}
	CTempValue(const  CTempValue& t) : val1(t.val1), val2(t.val2)
	{
		cout << "调用了拷贝构造函数!" << endl;
	};
	virtual ~CTempValue() //析构函数
	{
		cout << "调用了析构函数!" << endl;
	};

};

CTempValue Double(CTempValue& ts)
{
	CTempValue tmpm; //这里会消耗一次构造和一次析构函数的调用 // 创建命名局部对象
	tmpm.val1 = ts.val1 * 2;
	tmpm.val2 = ts.val2 * 2;
	return tmpm;  //断点到这里，会发现调用了拷贝构造函数和析构函数，这表示生成了临时对象 // 返回命名对象
}

int main()
{
	CTempValue ts1(10, 20);
	Double(ts1); //为简单，先不接收函数Double返回的结果
}

```

- 没有看到拷贝构造函数调用的原因是编译器进行了返回值优化（RVO），这是一种标准允许的优化技术，旨在提高代码效率。

按照C++标准，**理论上 `Double` 函数的返回过程**应该是：

1. 在函数内部创建 `tmpm` 对象
2. 返回时，使用拷贝构造函数创建一个临时对象
3. 函数结束后，`tmpm` 被析构
4. 临时对象被返回给调用者

#### 解决方案——优化

```c++
//将main函数里改为
CTempValue ts1(10, 20);
CTempValue && ts3 = Double(ts1); // 使用右值引用接收返回值
```

- 使用右值引用：直接绑定到临时对象，不调用拷贝构造函数
  1. `Double(ts1)` 函数执行，创建并返回一个 `CTempValue` 对象
  2. 返回的对象是一个右值（临时对象）
  3. `CTempValue && ts3` 直接绑定到这个临时对象
  4. 临时对象的生命周期被延长，直到 `ts3` 离开作用域

#### 再优化

```c++
CTempValue Double(CTempValue& ts)
{
	return CTempValue(ts.val1 * 2, ts.val2 * 2);// 直接返回临时对象
}
```

使用右值引用接收返回值 (`CTempValue && ts3 = Double(ts1)`) 在这两种情况下都能延长临时对象的生命周期，但版本2更可能完全避免临时对象的创建。

### (4)类外的运算符重载之中的优化

```c++
#include<iostream>
using namespace std;

class mynum
{
public:
	mynum() //构造函数
	{
		cout << "调用了构造函数!" << endl;
	}

	mynum(const  mynum& t)  //拷贝构造函数
	{
		cout << "调用了拷贝构造函数!" << endl;
	};
	virtual ~mynum() //析构函数
	{
		cout << "调用了析构函数!" << endl;
	};

public:
	int num1;
	int num2;
};

//类外的运算符重载，针对两个mynum类对象的加法运算符
mynum operator+(mynum& tmpnum1, mynum& tmpnum2) 
{
	mynum result;// 创建局部对象
	result.num1 = tmpnum1.num1 + tmpnum2.num1;
	result.num2 = tmpnum1.num2 + tmpnum2.num2;
	return result;// 返回局部对象
}

int main()
{
	mynum tm1;
	tm1.num1 = 10;
	tm1.num2 = 100;

	mynum tm2;
	tm2.num1 = 20;
	tm2.num2 = 200;

	mynum tm3 = tm1 + tm2;

}
```

在这段代码中，`mynum tm3 = tm1 + tm2;` 这一行没有产生明显的临时对象，主要是由于**编译器的返回值优化（RVO）** 和 **拷贝省略（Copy Elision）** 技术。

如果禁用优化，执行过程将是：

1. 在 `operator+` 函数中创建 `result` 对象
2. 返回时，使用拷贝构造函数创建临时对象
3. 使用拷贝构造函数将临时对象拷贝到 `tm3`
4. 销毁临时对象
5. 销毁 `result` 对象

这会生成大量的构造函数和析构函数调用。

#### 在禁用优化的前提下——如何优化

```c++
class mynum
{
public:	
	mynum(int x = 0, int y = 0) :num1(x), num2(y) //构造函数
	{
		cout << "调用了构造函数!" << endl;
	}

	mynum(const  mynum& t)  //拷贝构造函数
	{
		cout << "调用了拷贝构造函数!" << endl;
	};
	virtual ~mynum() //析构函数
	{
		cout << "调用了析构函数!" << endl;
	};


public:
	int num1;
	int num2;
};
mynum operator+(mynum& tmpnum1, mynum& tmpnum2)
{
	return mynum(tmpnum1.num1 + tmpnum2.num1, tmpnum1.num2 + tmpnum2.num2);
}


```

版本2（直接构造方式）明显优于版本1，因为它：

1. 性能更好，避免了不必要的默认构造和赋值操作
2. 代码更简洁，可读性更高
3. 更容易被编译器优化
4. 构造函数设计更合理，支持更多使用场景