# 第15章 模板与泛型

## 1、模板概念

- 模板一般分为  函数模板   和   类模板。

### （1）函数模板

- 通用函数，函数返回值类型和形参类型不确定，使用时再确定。

- 函数模板的声明：

  ```c++
  // 函数模板的声明
  template <typename T>
  返回类型 函数名(T parameter) {
      // 函数体
  }
  
  // 多个类型参数
  template <typename T, typename U>
  ReturnType functionName(T param1, U param2) {
      // 函数体
  }
  ```

- 函数模板的调用：

  - **隐式实例化调用**：让编译器根据参数自动推导模板参数类型
  
    ```c++
    template<typename T>
    void mySwap(T &a,T &b)
    {
        T temp;
        temp=a;
        a=b;
    }
    //自动类型推导
    mySwap(a,b);
    ```
  
  - **显式实例化调用**：在调用时显式指定模板参数类型
  
    ```c++
    //显示指定类型
    mySwap<int>(a,b);
    ```

### （2）类模板

- 通用类，类中的成员的数据类型不确定，用虚拟类型来代表，使用时再确定。
- 类模板  **没有自动类型推导** 的使用方式
- 类模板 在模板参数列表中**可以有默认参数**。

- 类模板的定义：

  ```c++
  template <class 形参1名,class 形参2名>
      class 类名
      {
          
  	};
  
  //声明类模板————示例
  template <class NameType,class AgeType>
      class Person
      {
          public:
          	Person(NameType name,AgeType age)
              {
                  this->m_Name=name;
                  this->m_Age=age;
              }
          NameType m_Name;
          AgeType m_Age;
      };
  ```

- 类模板中的成员函数：
  - 普通类中的成员函数 在一开始创建类时就可以一起创建
  - 类模板中的成员函数 必须 **在调用时创建**

- 类模板实例化出来的对象  向 函数传参的方式

  1. 指定传入的类型——直接显示对象的数据类型

     ```c++
     //普通函数
     void printPerson(Person<string,int> &p)
     {
         p.showPerson();
     }
     int main()
     {
     	Person<string,int> p("孙悟空",999);
         printPerson(p);
     }
     ```

  2. 参数模板化——将对象中的参数变成模板传递

     ```c++
     template <class T1,class T2>
         void printPerson2(Person <T1,T2> &p)
     {
         p.show
     }
     ```

     

  3. 整个类模板化——将这整个对象类型模板化进行传递