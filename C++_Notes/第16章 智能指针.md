# 第16章 智能指针

- 智能指针的引入是为了防止无意之间写出有内存泄漏的程序。

## 1、直接内存管理new  / delete

- 一个典型的 C++ 程序在内存中（从低地址到高地址）分为以下几个主要区域：

  ```
  高地址
  +-----------------------+
  |  命令行参数和环境变量   | 
  +-----------------------+ 
  |        栈 (Stack)      | ↓ (向下增长)————>局部变量、函数参数、返回值地址等。
  +-----------------------+
  |                  ↓    |
  |        内存映射段  ↑    |
  +-----------------------+
  |        堆 (Heap)       | ↑ (向上增长)————————>动态分配的内存（通过 new/malloc |                       |                     分配）。
  +-----------------------+
  |   BSS 段 (未初始化数据) | ————————>未初始化的全局变量和静态变量。操作系统会在程序 |                       |          加载时将此段内存全部初始化为零。
  +-----------------------+
  |   数据段 (已初始化数据)  |——————> 已初始化的全局变量和静态变量,在程序开始前就分配   |                       |        好，并持续到程序结束。
  +-----------------------+
  |   代码段 (文本段)       | —————————>存放：程序的机器代码（指令），常量字符串字面量
  低地址
  ```

- **动态分配：**
  - `new` 和 `delete` 是运算符，用于在**堆**上动态地分配和释放内存。与栈（Stack）上的自动内存管理不同，堆上的内存生命周期完全**由程序员控制**。
- **注意点：**
  1. new返回的是该对象的指针。delete的作用是回收一块用new分配的内存，用来释放内存。
  2. new和delete必须成对使用。delete一块内存只能delete一次。所以建议每次delete以后给这个指针赋值空指针，表明其不指向任何内存。
  3. `new`运算符做了两件事：分配内存  和   **调用构造函数**初始化该内存
  4. `delete`运算符做了两件事：**调用析构函数**  和   释放内存
  5. 动态分配数组： `new[]`   `delete[]`     
     - 在为new出来的数组分配内存时，C++会多分配4个字节的大小用来专门保存数组的大小，这样delete的时候就知道应该调用多少次析构函数了。

```c++
int* pointi = new int; //指针指向的是一个int对象且没有名字，不赋初值的情况下指针指向一个不确定的值
int* pointi = new int(100); //指针pointi指向的内容是100

delete pointi;
pointi = null;
```

## 2、智能指针

- 智能指针实际上是一个类模板，需要用到 `< >`， `< >`里面是指针可以指向的类型，后面再跟上智能指针的名字。

- C++智能指针有哪些？它们的区别是什么？

  ​	主要有三种，均位于 `<Memory>`头文件中：

  1. `std::unique_ptr<T>`（独占所有权）

     ​	不能被复制，只能被移动（`std::move`)。

     ​	适合于独占资源管理，例如文件、网络连接。

     ​	用`std::make_unique<T>(args...)`创建。

  2. `std::shared_ptr<T>`（共享所有权）

     ​	采用引用计数，多个 `shared_ptr`可以共享同一对象，最后一个销毁时释放资源。

     ​	存在循环引用风险，可以配合 `std::weak_ptr`解决。

     ​	用`std::make_shared<T>(args...)`创建，减少内存分配开销。

  3. `std::weak_ptr<T>`（弱引用）

     ​	依赖 `shared_ptr`，不会增加引用计数。

     ​	用于解决 `shared_ptr`循环引用问题。

     ​	可以通过 `lock()`获取 `shared_ptr`，判断对象是否仍然有效。

### （1）`shared_prt`指针

#### 1.核心思想：共享所有权（Shared Ownership）。

​	多个 `shared_ptr` 可以同时指向（拥有）同一个对象。

​	系统内部通过**引用计数机制**来跟踪有多少个 `shared_ptr` 指向该对象。每一个 `shared_ptr`指向相同的对象（内存）。只有最后一个指向该对象的 `shared_ptr`指针不需要指向这个对象的时候，指针才会去析构所指向的对象。

​	每当一个 `shared_ptr` 被复制时，引用计数增加；每当一个 `shared_ptr` 被销毁或重置时，引用计数减少。当引用计数变为零时，对象被自动删除。

```C++
shared_ptr<指定的类型>智能指针名;

//默认初始化   指针里面保存的是空指针nullptr
shared_ptr<string> p1;//指向string的智能指针。名字为p1

//常规初始化————和new配合使用
    shared_ptr<int> pi(new int(100)); //pi指向一个值为100的int型数据

```

#### 2.make_shared函数

推荐使用 `std::make_shared` 工厂函数来创建 `shared_ptr`，这是最安全、最高效的方式。

它可以在动态内存（堆）中分配并初始化一个对象。然后返回指向此对象的`shared_ptr`

```c++
	shared_ptr<int> p2 = std::make_shared<int>(100); // 创建一个 shared_ptr，管理一个值为 100 的 int

	shared_ptr<string> p3 = std::make_shared<string>(5, 'a'); // 创建一个 shared_ptr，管理一个 string 对象// 这个 string 对象由 string 的构造函数 string(size_t count, char ch) 初始化// 即生成一个包含 5 个 'a' 字符的字符串："aaaaa"

	shared_ptr<int> p4 = make_shared<int>(); //p4指向一个int，int里保存的值是0；这个就是值初始化
	p4 = make_shared<int>(400); //p4释放刚才的对象，重新指向新对象

	auto p5 = std::make_shared<string>(5, 'a'); // 使用 auto 关键字自动推导类型，简化代码
// p5 的类型会被推导为 std::shared_ptr<std::string>

	cout << "测试" << endl;
```

#### 3.`shared_ptr`引用计数的增加与减少

1. 引用计数增加：

   （1）用一个指针初始化另一个指针——智能指针复制

   ```c++
   	auto p6 = std::make_shared<int>(100);
   	auto p7(p6);  //写成auto p7 = p6;也可以，智能指针拷贝，p7和p6指向相同的对象，此对象目前有两个引用者     	
   ```

   （2）把智能指针当成实参往函数里面传递

   ​	**按值传递智能指针**：

   - 会增加引用计数（因为创建了副本）

   - 函数结束时，副本被销毁，引用计数减少

     **按引用传递智能指针**：

   - 不会增加引用计数（因为没有创建副本）

   - 适合在函数内部访问但不拥有对象的情况

   （3）作为函数的返回值

   - 返回值时会创建副本，增加引用计数
   - 如果返回值没有被接收（赋值给变量），临时对象会立即被销毁，引用计数恢复

   ```c++
   void myfunc(shared_ptr<int> ptmp) //如果传递引用作为形参进来，则引用计数不会增加
   {
   	return;
   }
   shared_ptr<int> myfunc2(shared_ptr<int>& ptmp) // 按引用传递，不会增加引用计数，所以计数还是为2
   {
   	return ptmp;// 返回时会创建副本，增加引用计数
   }
   
   int main()
   {
   	auto p6 = std::make_shared<int>(100);
   	auto p7(p6);  //写成auto p7 = p6;也可以，智能指针拷贝，p7和p6指向相同的对象，此对象目前有两个引用者     	
   	myfunc(p7); //当然，这个函数执行完毕后，这个指针的引用计数会恢复
   	auto p8 = myfunc2(p7); //如果有p8接收myfunc2函数返回值，那么此时引用计数会变成3
   	//myfunc(p7); //引用计数保持2不变，因为没有变量来接收myfunc(p7)调用的返回值
   }
   ```

2. 引用计数减少：

   （1）给`shared_ptr`赋一个新值，让其指向一个新对象

   ```c++
   auto p6 = std::make_shared<int>(100);  // 对象A: 值100, 引用计数=1
   auto p7(p6);                           // 对象A: 值100, 引用计数=2 (p6和p7共享)
   auto p8 = myfunc2(p7);                 // 对象A: 值100, 引用计数=3 (p6, p7和p8共享)
   
   p8 = std::make_shared<int>(200); // p8指向新对象B，p8计数1，p6,p7计数恢复为2
   p7 = std::make_shared<int>(200); // p7指向新对象C，p7计数1，p6指向的原对象A恢复计数为1
   p6 = std::make_shared<int>(200); // p6指向新对象D,p6计数1，原对象A引用计数为0,内存被释放
   ```

   （2）局部的`shared_ptr`离开其作用域

   （3）当一个`shared_ptr`引用计数变为0，它会自动释放自己所管理的对象

#### 4.`shared_ptr`指针常用操作

1. ##### use_count() - 获取引用计数

   用于返回多少个智能指针指向某个对象

   ```c++
   auto p13 = std::make_shared<int>(800);
   std::cout << p13.use_count() << std::endl; // 输出: 1
   
   auto p14 = p13;
   std::cout << p13.use_count() << std::endl; // 输出: 2
   ```

2. #####  unique() - 检查是否唯一拥有

   是否该智能指针独占某个指向的对象，是则输出true，否则输出false

   ```c++
   auto p15 = std::make_shared<int>(900);
   std::cout << p15.unique() << std::endl; // 输出: true (1)
   
   auto p16 = p15;
   std::cout << p15.unique() << std::endl; // 输出: false (0)
   ```

3. #####  reset() - 重置指针

   （1）无参数重置 - 释放当前对象

   - 当pi是唯一指向该对象的指针时，则释放pi指向的对象，将pi置空。

   ```c++
   {
       shared_ptr<int> pi(new int(100));  // 创建 pi，它独占指向新分配的 int(100)，引用计数为1
       pi.reset(); //引用计数从1减到0  由于引用计数变为0，对象被销毁 pi被置空
       if (pi == nullptr) // 条件成立
       {
           cout << "pi被置空" << endl; 
       }
   }
   ```

   - 当pi不是唯一指向该对象的指针，则不释放pi指向的对象，但是指向该对象引用计数会减1。同时将pi置空

   ```c++
   {
       shared_ptr<int> pi(new int(100));  // 创建 pi，指向新分配的 int(100)，引用计数为1
       auto pi2(pi); // 拷贝构造，pi2与pi共享所有权，引用计数变为2
       pi.reset(); // pi放弃所有权，引用计数减少1，pi被置空
       // 此时pi2仍然指向对象，所以对象不会被销毁，引用计数为1
   }
   ```

   **总结**：

   1. **调用 reset() 的智能指针**：
      - 总是会放弃所有权
      - 总是会变为 `nullptr`
      - 总是会使全局引用计数减 1
   2. **对象是否被销毁**：
      - 仅当引用计数减为 0 时，对象才会被销毁
      - 如果调用 reset() 后引用计数仍大于 0，对象继续存在

   （2）带指针参数重置 - 指向新对象

   - 当pi是唯一指向该对象的指针时，则释放pi指向的对象，让pi指向新内存。

   - 当pi不是唯一指向该对象的指针，则不释放pi指向的对象，但是指向该对象引用计数会减1。同时将pi指向新内存。

     ```c++
     shared_ptr<int> pi(new int(100));
     pi.reset(new int(1)); //释放原内存（内容为100的内存），指向新内存（内容为1的内存）
     ```

4. ##### *解引用操作符

   ```c++
   auto p11 = std::make_shared<int>(700);
   
   // operator* - 解引用
   int value = *p11; // value = 700
   
   // operator-> - 访问成员
   struct Point { int x, y; };
   auto p12 = std::make_shared<Point>(Point{10, 20});
   int x = p12->x; // x = 10
   ```

5. ##### get() - 获取原始指针

   | 特性         | `std::shared_ptr::get()`                                     |
   | :----------- | :----------------------------------------------------------- |
   | **目的**     | 获取被管理对象的原始指针，用于不涉及所有权转移的访问和传递。 |
   | **所有权**   | **不改变**引用计数和所有权。                                 |
   | **风险**     | 返回的指针可能因 `shared_ptr` 的 `reset()` 或析构而变为悬空指针。 |
   | **黄金法则** | **绝不**用 `get()` 返回的指针来创建新的智能指针。将其用途严格限制在“观察”而非“管理”生命周期。get返回的指针不可以delete。 |

6. ##### swap() - 交换内容

   用于交换两个智能指针所指向的对象，引用计数并不发生变化。

7. ##### = `nullptr`

   将所指向对象的引用计数减1，如引用计数变为0，则释放智能指针所指向的对象。

   同时将智能指针置空。

8. ##### 智能指针名字作为判断条件

   ```c++
   shared_ptr<string> ps1(new string("I Love China1!"));
   //若ps1指向一个对象，则条件成立
   if (ps1)//条件成立
   {			
       cout << "ps1" << endl; //执行
   }
   ```

9. ##### 指定删除器和数组问题

   - 智能指针可以在一定的时机自动删除它所指向的对象。默认情况下，使用`delete`运算符作为默认的删除它指向的对象的方式。

   - 或者自己指定删除器——一般只需要在参数中添加具体的删除器函数名即可（删除器是一个单形参的函数）

   - 一般用于——用`shared_ptr`管理动态数组时。需要指定自己的删除器，默认情况下 `std::shared_ptr` 使用 `delete` 而不是 `delete[]` 作为删除器，这会导致管理数组时出现问题。

     ```c++
     #include <memory>
     
     //方法一：使用 std::default_delete<T[]>
     std::shared_ptr<int> arr(new int[10], std::default_delete<int[]>());
     
     //方法二：使用 Lambda 表达式作为删除器
     std::shared_ptr<int> arr(new int[10], [](int* p) {
         delete[] p; // 明确使用 delete[]
     });
     
     //方法三：使用函数指针作为删除器
     // 先定义一个删除函数
     void array_deleter(int* p) {
         delete[] p;
     }
     
     // 然后使用它
     std::shared_ptr<int> arr(new int[10], array_deleter);
     
     // C++17 及之后版本可以这样使用
     std::shared_ptr<int[]> arr(new int[10]);
     
     // 还可以使用下标运算符访问元素
     arr[0] = 42;
     arr[1] = 43;
     ```

- #### `shared_ptr`使用场景、陷阱、性能分析与使用建议

  1. ##### 慎用裸指针

     | 特性           | 裸指针 (Raw Pointer)                  | `std::shared_ptr`                        |
     | :------------- | :------------------------------------ | :--------------------------------------- |
     | **内存管理**   | 手动管理，需要显式调用 `new`/`delete` | 自动管理，基于引用计数                   |
     | **所有权语义** | 没有明确的所有权概念                  | 明确的所有权共享语义                     |
     | **空悬指针**   | 常见问题，难以避免                    | 几乎不会出现（如果正确使用）             |
     | **循环引用**   | 不适用                                | 可能发生，需要使用 `std::weak_ptr` 解决  |
     | **性能开销**   | 无额外开销                            | 有少量开销（引用计数管理）               |
     | **异常安全**   | 不安全，异常可能导致内存泄漏          | 安全，异常不会导致内存泄漏               |
     | **线程安全**   | 需要手动同步                          | 引用计数操作是原子的，但对象访问需要同步 |

  2. ##### 慎用get返回的指针

     - **`get()` 返回的指针的生命周期依赖于原始 `shared_ptr`**，不应在原始 `shared_ptr` 可能被销毁后使用。
     - **绝对不要使用 `get()` 返回的指针创建新的智能指针**，这会导致双重释放。
     - **在多线程环境中使用 `get()` 要格外小心**，因为无法安全地检测指针是否已悬空。
     - **优先考虑使用 `std::weak_ptr` 作为观察者**，而不是存储 `get()` 返回的原始指针。
     - **只在必要时使用 `get()`**，例如与不管理生命周期的API交互时。

  3. ##### 用`enable_shared_from_this`返回`this`

     

  4. ##### 避免循环引用

### （2）`unique_ptr`指针

#### 1. 创建和基本使用

```c++
#include <memory>
#include <iostream>

int main() {
    // 创建 unique_ptr (C++14 推荐方式)————make_unique函数
    auto ptr1 = std::make_unique<int>(42);
    
    // 创建 unique_ptr (传统方式)——unique_ptr和new配合
    std::unique_ptr<int> ptr2(new int(100));
    
    // 使用指针
    std::cout << *ptr1 << std::endl; // 输出: 42
    *ptr2 = 200;
    std::cout << *ptr2 << std::endl; // 输出: 200
    
    // 检查是否为空
    if (ptr1) {
        std::cout << "ptr1 is not null" << std::endl;
    }
    
    return 0;
} // ptr1 和 ptr2 自动释放内存
```

#### 2. 独占所有权（无法复制）

```c++
std::unique_ptr<int> ptr1 = std::make_unique<int>(42);

// 错误！unique_ptr 不能复制
// std::unique_ptr<int> ptr2 = ptr1;

// 正确！移动语义转移所有权
std::unique_ptr<int> ptr3 = std::move(ptr1);

// 现在 ptr1 为空，ptr3 拥有对象
std::cout << "ptr1 is " << (ptr1 ? "not null" : "null") << std::endl; // null
std::cout << "ptr3 points to " << *ptr3 << std::endl; // 42
```

#### 3. 释放和重置

- `release`成员函数：切断了智能指针和其所指向的对象之间的联系，返回一个裸指针，将智能指针置空。返回的裸指针可以手工delete释放，也可以用来初始化另外一个智能指针或者给另一个智能指针赋值。

- `reset`成员函数：当reset不带参数时，释放智能指针指向的对象，并将智能指针置空。当reset带参数时，释放智能指针原来所指向的内存，让该智能指针指向新内存。
- `= nullptr` ： 释放智能指针所指向的对象，并将智能指针置空。

```c++
auto ptr = std::make_unique<int>(42);

// 释放所有权，返回原始指针，unique_ptr 变为空
int* raw_ptr = ptr.release();
//返回裸指针之后需要手动清除
// 现在需要手动管理 raw_ptr
delete raw_ptr;

// 重置指针
auto ptr2 = std::make_unique<int>(100);
ptr2.reset(); // 释放当前对象，ptr2 变为空
ptr2.reset(new int(200)); // 释放当前对象，管理新对象

unique_ptr<string> ps1(new string("I Love China!"));
ps1 = nullptr; //释放ps1指向的对象，并将ps1置空
```

#### 4.管理动态数组

`std::unique_ptr` 对数组有内置支持，比 `shared_ptr` 更方便：

C++11/14 方式：

```c++
// 管理动态数组
std::unique_ptr<int[]> arr(new int[5]);

// 使用下标访问元素
for (int i = 0; i < 5; ++i) {
    arr[i] = i * 10;
    std::cout << arr[i] << " ";
}
// 输出: 0 10 20 30 40
```

C++17 及更高版本：

```c++
// C++17 可以使用 make_unique 创建数组
auto arr = std::make_unique<int[]>(5);

for (int i = 0; i < 5; ++i) {
    arr[i] = i * 10;
}
```

#### 5、get成员函数

- 返回智能指针中保存的对象，也就是一个裸指针。

#### 6、*解引用

- `*p`：解引用，获得p指向的对象。

#### 7.`swap`成员函数

- 用于交换两个智能指针所指向的对象

#### 8.智能指针名字作为判断条件

```c++
unique_ptr<string> ps1(new string("I Love China1!"));
//若ps1指向一个对象，则为true
if (ps1) //条件成立
{
	//执行
	cout << "ps1指向了一个对象" << endl;
}
```

#### 9.转换成`shared_ptr`类型

- 转换可以通过显式构造`shared_ptr`来实现，因为`shared_ptr`有一个构造函数，可以接受一个`unique_ptr`右值。
- 注意：转换后，`unique_ptr`将释放所有权，变为`nullptr`，而`shared_ptr`将接管对象的所有权。

```c++
#include <memory>
#include <iostream>

int main() {
    // 创建一个 unique_ptr
    std::unique_ptr<int> uniquePtr = std::make_unique<int>(42);
    //通过 std::move  把unique_ptr转换成右值
    // 转换为 shared_ptr
    std::shared_ptr<int> sharedPtr(std::move(uniquePtr));
      
    return 0;
}
```

```c++
auto myfunc()//函数返回类型：这里返回的是 std::unique_ptr<std::string>
{
    //创建临时对象：unique_ptr<string>(new string("I Love China!")) 创建一个临时 unique_ptr 对象  
    //返回的临时对象是一个右值，可以被移动而不是被复制
    return unique_ptr<string>(new string("I Love China!"));
    //return std::make_unique<std::string>("I Love China!"); // C++14 推荐方式
}
```

