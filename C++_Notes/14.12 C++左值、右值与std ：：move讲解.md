# C++左值、右值与std ：：move讲解

## 1、左值和右值

### (1)左值 value

具有**地址**，存储在内存中。    

可以出现在赋值号=左边

可以取地址&

**变量、对象、数组元素**都是左值

```c++
int a=10;  //a整型变量  也可以成为对象————对象是一块存储区域  
```

### (2)右值  Rvalue

通常没有地址、存储在寄存器或者临时内存中。

不能出现在赋值号=左边

不能取地址&  ——除非绑定到const左值引用

字面量、表达式计算结果都是右值

```C++
int y=10+5; //（10+5）是右值   就是一个数值  是没有地址的
10=y;   //错误 10是右值 不可以放在=左边
int &ref=10; //错误 ，普通引用不可以绑定右值
const int & cref=10;   //可以   const 引用可以绑定右值
```

## 2、左值引用和右值引用

### (1)左值引用

```c++
int a=10;  //a变量 是地址的别名  0x222224(a)  内容：10
int &b = a;  //引用是变量的别名  引用是通过指针实现的  0x2222230(b)   内容：0x222224
b=20; // 通过b的内容找到a 替换a的内容为20
```

### (2)右值引用

```c++
const int && c =20 ; //b是对右值20的引用   右值引用就是右值的临时变量
//右值20 没有对应的存储地址  所以暂时存储在栈里的临时地址  再用c指向临时地址
```

## 3、std :: move 

- move函数的作用是
  - std: :move(a)   用于触发移动构造和移动赋值，避免深拷贝，提升性能
  - std: :move(a)   将一个左值强制转换成右值。

```C++
int a=10;
const int &&c=a; //错误  a是左值  不可以进行右值引用
const int && c = std::move(a); //正确  move函数把左值a强制转换成右值  c绑定了右值
//也就是  读取了a的地址 由c指向a 
int &b = a; 
const int && c = std::move(a); //这两句的汇编代码一模一样
//std::move(a)  现在是右值  也叫做亡值  move仅仅只是改变了a的性质，不会修改a本身  a仍然是左值
```

 std::move(a)  只是告诉编译器a变成右值，也就是改变了a的性质，不会修改a本身 ，a仍然是左值。

```c++
#include <iostream>
#include <utility>
#include <string>
int main()
{
    std::string str1="Hello";     //0x222224(str1)  内容： hello
    //std::string str2=str1;  //str1拷贝给str2 触发拷贝构造（深拷贝）
    //如果字符串特别长 会造成深拷贝带来的资源浪费
    //0x222230(str2)  内容： hello  //0x222224(str1)  内容： 空
    std::string str2=std::move(str1);  //触发移动构造 ——将str1内容移动至str2
    std::cout<<"str1:"<<str1<<endl;
    std::cout<<"str2:"<<str2<<endl;
}
```

